// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// todo: h-index, students under professors, and projects
model User {
  id String @id

  firstName String?
  lastName String?
  designation String?
  institution String?
  title String?
  location String?
  website String?
  bio String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  following Connection[] @relation("Following")
  followers Connection[] @relation("Followers")

  // Research relationships
  researchInterests ResearchInterest[]
  publications Publication[]
  
  // Event relationships
  eventRegistrations EventRegistration[]
  eventReviews EventReview[]
  bookmarkedEvents Event[] @relation("EventBookmarks")
  organizedEvents Event[] @relation("EventOrganizer")
  eventSpeakers EventSpeaker[] @relation("EventSpeakers")
  sessionSpeakers SessionSpeaker[]
  posterAuthors PosterAuthor[]
  
  // Group relationships
  ledGroups Group[] @relation("GroupLeader")
  groupMemberships GroupMember[]
  groupAnnouncements GroupAnnouncement[]
  groupProjectMembers GroupProjectMember[]
  
  // Repository relationships
  repositoryPapers RepositoryPaperAuthor[]
  paperReviews PaperReview[]
  paperBookmarks PaperBookmark[]
  reviewHelpfulVotes ReviewHelpfulVote[]
  
  // Messaging relationships
  directConversations ConversationParticipant[]
  sentMessages Message[]
  channelMemberships ChannelMember[]
  
  // Job relationships
  postedJobs Job[] @relation("JobPoster")
  jobApplications JobApplication[]
  bookmarkedJobs JobBookmark[]
  
  // Feed/Post relationships
  posts Post[] @relation("PostAuthor")
  postReactions PostReaction[]
  postComments PostComment[]
  commentReactions CommentReaction[]
  postBookmarks PostBookmark[]
  postShares PostShare[]
  mentionedInPosts PostMention[]
}

model Connection {
  id String @id @default(uuid())

  followerId String
  followingId String
  status ConnectionStatus @default(Pending)

  createdAt DateTime @default(now())

  follower User @relation("Following", fields: [followerId], references: [id], onDelete: Cascade) // should we have onDelete: Cascade here?
  following User @relation("Followers", fields: [followingId], references: [id], onDelete: Cascade)
}

enum ConnectionStatus {
  Pending
  Accepted
  Rejected
}

// ============================================
// Publication Models
// ============================================
model Publication {
  id String @id @default(uuid())

  title String
  abstract String? @db.Text
  publicationDate DateTime?
  journal String?
  doi String? @unique // digital object identifier should be unique

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  authors User[] // should we store the order of authors? if yes, we need to create a new join table 

  citations_made Publication[] @relation("Citations")
  citations_received Publication[] @relation("Citations")
  
  // Repository link
  repositoryPaper RepositoryPaper? @relation("PublicationFromRepository") // if this publication came from a repository preprint
  paperCitationsReceived PaperCitation[] // citations from repository papers
  
  // Feed relationship
  sharedInPosts Post[]
}

model ResearchInterest {
  id String @id @default(uuid())

  interest String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  users User[]
}

// ============================================
// Event Models
// ============================================

model Event {
  id String @id @default(uuid())
  
  title String
  subtitle String?
  description String? @db.Text
  fullDescription String? @db.Text
  
  type EventType
  format EventFormat
  
  startDate DateTime
  endDate DateTime
  timezone String?
  
  price String? // can be free, $50, etc.
  currency String? // can be USD, EUR, etc.
  
  organizerId String?
  organizerName String?
  organizerLogo String?
  
  image String?
  website String?
  twitterHandle String?
  linkedinHandle String?
  isLive Boolean @default(false)
  isFeatured Boolean @default(false)
  
  maxAttendees Int?
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // relations
  organizer User? @relation("EventOrganizer", fields: [organizerId], references: [id])
  tags EventTag[]
  sessions Session[]
  speakers EventSpeaker[]
  posters Poster[]
  registrations EventRegistration[]
  reviews EventReview[]
  bookmarks User[] @relation("EventBookmarks")
  sharedInPosts Post[]
  
  @@index([type])
  @@index([format])
  @@index([startDate])
  @@index([endDate])
  @@index([isLive])
  @@index([isFeatured])
  @@index([organizerId])
}

enum EventType {
  Conference
  Workshop
  Symposium
  Seminar
  Webinar
  Other
}

enum EventFormat {
  Virtual
  InPerson
  Hybrid
}

model EventTag {
  id String @id @default(uuid())
  
  name String
  slug String? @unique
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  events Event[]
}

model Session {
  id String @id @default(uuid())
  
  eventId String
  title String
  description String? @db.Text
  
  startTime DateTime
  endTime DateTime
  timezone String?
  
  type SessionType
  
  room String?
  location String? // can be virtual gallery, track A, etc.
  
  videoUrl String?
  recordingUrl String?
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // relations
  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
  speakers SessionSpeaker[]
  
  @@index([eventId])
  @@index([startTime])
  @@index([type])
}

enum SessionType {
  Keynote
  Session
  Poster
  Workshop
  Tutorial
}
model SessionSpeaker {
  id String @id @default(uuid())
  
  sessionId String
  userId String
  
  role SessionSpeakerRole? 
  order Int? // for ordering multiple speakers - maybe not needed?
  
  createdAt DateTime @default(now())
  
  // relations
  session Session @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([sessionId, userId])
  @@index([sessionId])
  @@index([userId])
}

enum SessionSpeakerRole {
  KeynoteSpeaker
  Presenter
  Moderator
}
model EventSpeaker {
  id String @id @default(uuid())
  
  eventId String
  userId String? // optional since speaker might not be a user
  
  name String? // if speaker is not a user
  title String? // professor, university of X
  bio String? @db.Text
  image String?
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // relations
  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user User? @relation("EventSpeakers", fields: [userId], references: [id], onDelete: SetNull)
  
  // note - no unique constraint on [eventId, userId] because userId is nullable
  // multiple external speakers (no userId) can exist for same event
  @@index([eventId])
  @@index([userId])
}

model Poster {
  id String @id @default(uuid())
  
  eventId String
  title String
  abstract String? @db.Text
  
  imageUrl String?
  pdfUrl String?
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // relations
  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
  authors PosterAuthor[]
  
  @@index([eventId])
}

model PosterAuthor {
  id String @id @default(uuid())
  
  posterId String
  userId String
  
  order Int? // author order - maybe not needed?
  
  createdAt DateTime @default(now())
  
  // relations
  poster Poster @relation(fields: [posterId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([posterId, userId])
  @@index([posterId])
  @@index([userId])
}

model EventRegistration {
  id String @id @default(uuid())
  
  eventId String
  userId String
  
  status EventRegistrationStatus @default(Registered)
  
  registeredAt DateTime @default(now())
  cancelledAt DateTime?
  
  // relations
  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([eventId, userId])
  @@index([eventId])
  @@index([userId])
  @@index([status])
}

enum EventRegistrationStatus {
  Registered
  Cancelled
  Waitlisted
}

model EventReview {
  id String @id @default(uuid())
  
  eventId String
  userId String
  
  rating Int // 1-5
  comment String? @db.Text
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // relations
  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([eventId, userId])
  @@index([eventId])
  @@index([userId])
  @@index([rating])
}

// ============================================
// Research Group Models
// ============================================

model Group {
  id String @id @default(uuid())
  
  name String
  description String? @db.Text
  fullDescription String? @db.Text
  
  field String? // research field
  institution String?
  
  leaderId String
  founded DateTime? // when the group was founded
  
  maxMembers Int?
  
  // Privacy & Access Settings
  visibility GroupVisibility @default(Public)
  joinRequiresApproval Boolean @default(false)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // relations
  leader User @relation("GroupLeader", fields: [leaderId], references: [id], onDelete: Cascade)
  members GroupMember[]
  topics GroupTopic[]
  projects GroupProject[]
  announcements GroupAnnouncement[]
  channels Channel[]
  
  @@index([leaderId])
  @@index([field])
  @@index([institution])
  @@index([createdAt])
  @@index([visibility])
}

enum GroupVisibility {
  Public
  Private
  Unlisted
}

model GroupMember {
  id String @id @default(uuid())
  
  groupId String
  userId String
  
  role GroupMemberRole?
  status GroupMemberStatus @default(Active)
  
  // Admin permissions
  isAdmin Boolean @default(false) // allows managing group settings and members
  
  joinedAt DateTime @default(now())
  leftAt DateTime?
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // relations
  group Group @relation(fields: [groupId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([groupId, userId])
  @@index([groupId])
  @@index([userId])
  @@index([status])
  @@index([role])
  @@index([isAdmin])
}

enum GroupMemberRole {
  Founder
  Lead
  SeniorResearcher
  Researcher
  Postdoc
  PhDStudent
  MastersStudent
  ResearchAssistant
  Other
}

enum GroupMemberStatus {
  Active
  Pending
  Left
}

model GroupTopic {
  id String @id @default(uuid())
  
  name String
  slug String? @unique
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  groups Group[]
}

model GroupProject {
  id String @id @default(uuid())
  
  groupId String
  name String
  description String? @db.Text
  
  status GroupProjectStatus @default(Planning)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // relations
  group Group @relation(fields: [groupId], references: [id], onDelete: Cascade)
  members GroupProjectMember[]
  
  @@index([groupId])
  @@index([status])
}

enum GroupProjectStatus {
  Planning
  Active
  OnHold
  Completed
  Cancelled
}

model GroupProjectMember {
  id String @id @default(uuid())
  
  projectId String
  userId String
  
  role String? // project-specific role
  
  joinedAt DateTime @default(now())
  
  createdAt DateTime @default(now())
  
  // relations
  project GroupProject @relation(fields: [projectId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([projectId, userId])
  @@index([projectId])
  @@index([userId])
}

model GroupAnnouncement {
  id String @id @default(uuid())
  
  groupId String
  userId String
  
  title String
  content String? @db.Text
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // relations
  group Group @relation(fields: [groupId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([groupId])
  @@index([userId])
  @@index([createdAt])
}

// ============================================
// Repository Models (pre-print repository)
// ============================================

model RepositoryPaper {
  id String @id @default(uuid())
  
  title String
  abstract String? @db.Text
  
  categoryId String?
  status PaperStatus @default(Draft)
  
  currentVersion String? // like v1, v2
  currentPdfUrl String? // (can be derived from version)
  
  // aggregated metrics
  views Int @default(0)
  downloads Int @default(0)
  citations Int @default(0)
  reviewCount Int @default(0)
  averageRating Float? // from 1 to 5
  
  // link to publication if published
  publicationId String? @unique
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  submittedAt DateTime? // when first submitted (status changed from Draft to UnderReview)
  
  // relations
  category PaperCategory? @relation(fields: [categoryId], references: [id], onDelete: SetNull)
  authors RepositoryPaperAuthor[]
  versions PaperVersion[]
  reviews PaperReview[]
  keywords PaperKeyword[]
  bookmarks PaperBookmark[]
  citationsMade PaperCitation[] @relation("CitationsFrom")
  citationsReceived PaperCitation[] @relation("CitationsTo")
  publication Publication? @relation("PublicationFromRepository", fields: [publicationId], references: [id], onDelete: SetNull)
  sharedInPosts Post[]
  
  @@index([categoryId])
  @@index([status])
  @@index([createdAt])
  @@index([submittedAt])
  @@index([averageRating])
}

enum PaperStatus {
  Draft
  UnderReview
  Published
  Withdrawn
}

model RepositoryPaperAuthor {
  id String @id @default(uuid())
  
  paperId String
  userId String
  
  order Int // useful for author ordering
  affiliation String? // can override user's default affiliation
  
  createdAt DateTime @default(now())
  
  // relations
  paper RepositoryPaper @relation(fields: [paperId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([paperId, userId])
  @@index([paperId])
  @@index([userId])
  @@index([order])
}

model PaperVersion {
  id String @id @default(uuid())
  
  paperId String
  version String // like v1, v2
  
  changelog String? @db.Text // description of changes
  fileUrl String? // pdf file
  
  createdAt DateTime @default(now())
  
  // relations
  paper RepositoryPaper @relation(fields: [paperId], references: [id], onDelete: Cascade)
  
  @@unique([paperId, version])
  @@index([paperId])
  @@index([createdAt])
}

model PaperReview {
  id String @id @default(uuid())
  
  paperId String
  userId String?
  
  // reviewer info (can be anonymous)
  reviewerName String? // if not a user, or anonymous
  isAnonymous Boolean @default(false)
  
  rating Int // 1-5
  summary String? // brief summary
  content String? @db.Text // detailed review
  
  helpfulCount Int @default(0) // aggregated count, updated via ReviewHelpfulVote
  notHelpfulCount Int @default(0) // aggregated count, updated via ReviewHelpfulVote
  
  // review type
  reviewType ReviewType @default(Community)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // relations
  paper RepositoryPaper @relation(fields: [paperId], references: [id], onDelete: Cascade)
  user User? @relation(fields: [userId], references: [id], onDelete: SetNull)
  helpfulVotes ReviewHelpfulVote[]
  
  @@index([paperId])
  @@index([userId])
  @@index([rating])
  @@index([reviewType])
  @@index([createdAt])
}

enum ReviewType {
  Peer
  Community
}

model PaperCategory {
  id String @id @default(uuid())
  
  name String
  slug String? @unique
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  papers RepositoryPaper[]
}

model PaperKeyword {
  id String @id @default(uuid())
  
  keyword String @unique
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  papers RepositoryPaper[]
}

model PaperBookmark {
  id String @id @default(uuid())
  
  paperId String
  userId String
  
  createdAt DateTime @default(now())
  
  // relations
  paper RepositoryPaper @relation(fields: [paperId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([paperId, userId])
  @@index([paperId])
  @@index([userId])
}

model ReviewHelpfulVote {
  id String @id @default(uuid())
  
  reviewId String
  userId String
  
  isHelpful Boolean 
  
  createdAt DateTime @default(now())
  
  // relations
  review PaperReview @relation(fields: [reviewId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([reviewId, userId])
  @@index([reviewId])
  @@index([userId])
}

model PaperCitation {
  id String @id @default(uuid())
  
  fromPaperId String // paper that cites
  toPaperId String? // paper being cited (repository paper)
  toPublicationId String? // or published paper being cited
  
  // application logic must ensure exactly one of toPaperId or toPublicationId is set
  createdAt DateTime @default(now())
  
  // relations
  fromPaper RepositoryPaper @relation("CitationsFrom", fields: [fromPaperId], references: [id], onDelete: Cascade)
  toPaper RepositoryPaper? @relation("CitationsTo", fields: [toPaperId], references: [id], onDelete: Cascade)
  toPublication Publication? @relation(fields: [toPublicationId], references: [id], onDelete: Cascade)
  
  @@unique([fromPaperId, toPaperId])
  @@unique([fromPaperId, toPublicationId])
  @@index([fromPaperId])
  @@index([toPaperId])
  @@index([toPublicationId])
}

// ============================================
// Jobs Models
// ============================================

model Job {
  id String @id @default(uuid())
  
  title String
  description String? @db.Text
  requirements String? @db.Text
  responsibilities String? @db.Text
  qualifications String? @db.Text
  
  // organization info
  organizationName String
  department String?
  organizationLogo String?
  organizationWebsite String?
  
  // location
  location String? // simple city, country for now
  workMode WorkMode?
  
  // job details
  type JobType
  field String? // research field
  
  // compensation
  salaryMin Decimal?
  salaryMax Decimal?
  currency String? // eg USD, EUR, etc.
  salaryPeriod SalaryPeriod? // Annual, Monthly, Hourly
  
  // dates
  applicationDeadline DateTime?
  startDate DateTime?
  
  // posted by
  posterId String?
  contactEmail String?
  applicationUrl String? // link to external application
  
  // status
  status JobStatus @default(Open)
  isFeatured Boolean @default(false)
  
  // metadata
  views Int @default(0)
  applicationCount Int @default(0)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // relations
  poster User? @relation("JobPoster", fields: [posterId], references: [id], onDelete: SetNull)
  categories JobCategory[]
  applications JobApplication[]
  bookmarks JobBookmark[]
  sharedInPosts Post[]
  
  @@index([type])
  @@index([status])
  @@index([field])
  @@index([location])
  @@index([workMode])
  @@index([posterId])
  @@index([applicationDeadline])
  @@index([createdAt])
  @@index([isFeatured])
}

enum WorkMode {
  Remote
  Hybrid
  Onsite
}

enum JobType {
  PhD
  Postdoc
  Faculty
  ResearchScientist
  ResearchAssistant
  ResearchEngineer
  LabManager
  Internship
  Visiting
  Other
}

enum JobStatus {
  Open
  Closed
  Filled
  Expired
}

enum SalaryPeriod {
  Annual
  Monthly
  Hourly
}

model JobCategory {
  id String @id @default(uuid())
  
  name String
  slug String? @unique
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  jobs Job[]
}

model JobApplication {
  id String @id @default(uuid())
  
  jobId String
  userId String
  
  status ApplicationStatus @default(Submitted)
  
  // application materials
  coverLetter String? @db.Text
  resumeUrl String?
  additionalDocuments String[] // array of URLs to additional files
  
  // contact info (can override user profile)
  contactEmail String?
  contactPhone String?
  
  // additional info
  availableFrom DateTime? // when the candidate can start
  notes String? @db.Text
  
  employerNotes String? @db.Text 
  
  submittedAt DateTime @default(now())
  reviewedAt DateTime?
  respondedAt DateTime? // when the status changed from submitted
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // relations
  job Job @relation(fields: [jobId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([jobId, userId])
  @@index([jobId])
  @@index([userId])
  @@index([status])
  @@index([submittedAt])
}

enum ApplicationStatus {
  Submitted
  UnderReview
  Shortlisted
  Interviewing
  Offered
  Accepted
  Rejected
  Withdrawn
}

model JobBookmark {
  id String @id @default(uuid())
  
  jobId String
  userId String
  
  notes String? // personal notes about why the user saved
  
  createdAt DateTime @default(now())
  
  // relations
  job Job @relation(fields: [jobId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([jobId, userId])
  @@index([jobId])
  @@index([userId])
  @@index([createdAt])
}

// ============================================
// Feed/Post Models
// ============================================

model Post {
  id String @id @default(uuid())
  
  authorId String
  content String? @db.Text
  
  // post type and category
  type PostType @default(Text)
  visibility PostVisibility @default(Public)
  
  // rich content references (when sharing existing content)
  sharedPublicationId String?
  sharedEventId String?
  sharedJobId String?
  sharedPaperId String?
  
  // for repost/quote functionality
  originalPostId String? // if this is a repost/quote
  isQuote Boolean @default(false) // true if adding own content to repost
  
  // aggregated engagement metrics
  reactionCount Int @default(0)
  commentCount Int @default(0)
  shareCount Int @default(0)
  bookmarkCount Int @default(0)
  
  // for moderation
  isPinned Boolean @default(false)
  isEdited Boolean @default(false)
  deletedAt DateTime? // soft delete
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // relations
  author User @relation("PostAuthor", fields: [authorId], references: [id], onDelete: Cascade)
  sharedPublication Publication? @relation(fields: [sharedPublicationId], references: [id], onDelete: SetNull)
  sharedEvent Event? @relation(fields: [sharedEventId], references: [id], onDelete: SetNull)
  sharedJob Job? @relation(fields: [sharedJobId], references: [id], onDelete: SetNull)
  sharedPaper RepositoryPaper? @relation(fields: [sharedPaperId], references: [id], onDelete: SetNull)
  originalPost Post? @relation("PostReposts", fields: [originalPostId], references: [id], onDelete: SetNull)
  reposts Post[] @relation("PostReposts")
  
  reactions PostReaction[]
  comments PostComment[]
  bookmarks PostBookmark[]
  shares PostShare[]
  mentions PostMention[]
  hashtags PostHashtag[]
  attachments PostAttachment[]
  
  @@index([authorId])
  @@index([type])
  @@index([visibility])
  @@index([createdAt])
  @@index([isPinned])
  @@index([deletedAt])
  @@index([originalPostId])
}

enum PostType {
  Text
  Image
  Link
  Publication
  Event
  Job
  Paper
  Poll // for future polls, if needed
}

enum PostVisibility {
  Public
  Connections
  Private // only visible to author, might be overkill, but keeping for now
}

model PostReaction {
  id String @id @default(uuid())
  
  postId String
  userId String
  
  type ReactionType @default(Like)
  
  createdAt DateTime @default(now())
  
  // relations
  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([postId, userId]) // one reaction per user per post
  @@index([postId])
  @@index([userId])
  @@index([type])
}

enum ReactionType {
  Like
  Celebrate
  Insightful
  Support
}

model PostComment {
  id String @id @default(uuid())
  
  postId String
  userId String
  
  content String @db.Text
  
  // for nested comments (replies)
  parentCommentId String? // if this is a reply to another comment
  
  // aggregated engagement metrics
  reactionCount Int @default(0)
  replyCount Int @default(0)
  
  isEdited Boolean @default(false)
  deletedAt DateTime? // soft delete
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // relations
  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  parentComment PostComment? @relation("CommentReplies", fields: [parentCommentId], references: [id], onDelete: Cascade)
  replies PostComment[] @relation("CommentReplies")
  reactions CommentReaction[]
  
  @@index([postId])
  @@index([userId])
  @@index([parentCommentId])
  @@index([createdAt])
  @@index([deletedAt])
}

model CommentReaction {
  id String @id @default(uuid())
  
  commentId String
  userId String
  
  type ReactionType @default(Like)
  
  createdAt DateTime @default(now())
  
  // relations
  comment PostComment @relation(fields: [commentId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([commentId, userId])
  @@index([commentId])
  @@index([userId])
}

model PostMention {
  id String @id @default(uuid())
  
  postId String
  userId String // user being mentioned
  
  createdAt DateTime @default(now())
  
  // relations
  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([postId, userId])
  @@index([postId])
  @@index([userId])
}

model PostHashtag {
  id String @id @default(uuid())
  
  name String // without the # symbol
  slug String @unique
  
  // trending metrics
  postCount Int @default(0)
  lastUsedAt DateTime @default(now())
  
  createdAt DateTime @default(now())
  
  posts Post[]
  
  @@index([slug])
  @@index([postCount])
  @@index([lastUsedAt])
}

model PostAttachment {
  id String @id @default(uuid())
  
  postId String
  
  type AttachmentType
  url String // file URL
  fileName String?
  fileSize Int? // in bytes
  mimeType String?
  
  // for images
  width Int?
  height Int?
  altText String?
  
  // for links
  linkTitle String?
  linkDescription String?
  linkImage String? // og:image
  
  order Int @default(0) // ??: for multiple attachments, maybe not needed?
  
  createdAt DateTime @default(now())
  
  // relations
  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)
  
  @@index([postId])
  @@index([type])
}

enum AttachmentType {
  Image
  Video
  Document
  Link
}

model PostBookmark {
  id String @id @default(uuid())
  
  postId String
  userId String
  
  notes String? // user's personal notes about why they saved
  
  createdAt DateTime @default(now())
  
  // relations
  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([postId, userId])
  @@index([postId])
  @@index([userId])
  @@index([createdAt])
}

model PostShare {
  id String @id @default(uuid())
  
  postId String
  userId String // user who shared
  
  // share context
  sharedWith ShareTarget? // where it was shared
  comment String? // optional comment when sharing
  
  createdAt DateTime @default(now())
  
  // relations
  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([postId])
  @@index([userId])
  @@index([createdAt])
}

enum ShareTarget {
  Feed // (creates new post)
  Message 
  External
}

// ============================================
// Messaging Models
// ============================================

model Conversation {
  id String @id @default(uuid())
  
  type ConversationType
  
  // for direct messages
  participants ConversationParticipant[]
  
  // for channel conversations - supports both in one
  channel Channel?
  
  messages Message[]
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@index([type])
  @@index([updatedAt])
}

enum ConversationType {
  Direct
  Channel
}

// explicit join table to store createdAt (useful for showing when a convo started). if not needed, remove it later, and use prisma's implicit join.
model ConversationParticipant {
  id String @id @default(uuid())
  
  conversationId String
  userId String
  
  createdAt DateTime @default(now())
  lastReadAt DateTime? // tracks when user last read messages in this conversation (for unread counts)
  
  // relations
  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([conversationId, userId])
  @@index([conversationId])
  @@index([userId])
}

model Channel {
  id String @id @default(uuid())
  
  groupId String
  name String // like general, papers, experiments
  description String? @db.Text
  
  conversationId String? @unique // one-to-one with conversation
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // relations
  group Group @relation(fields: [groupId], references: [id], onDelete: Cascade)
  conversation Conversation? @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  members ChannelMember[]
  
  @@unique([groupId, name])
  @@index([groupId])
  @@index([name])
  @@index([conversationId])
}

model ChannelMember {
  id String @id @default(uuid())
  
  channelId String
  userId String
  
  // optional: for future private channels or muted channels
  role ChannelMemberRole? @default(Member)
  muted Boolean @default(false)
  
  joinedAt DateTime @default(now())
  lastReadAt DateTime? // tracks when user last read messages in this channel (for unread counts)
  
  // relations
  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([channelId, userId])
  @@index([channelId])
  @@index([userId])
}

enum ChannelMemberRole {
  Member
  Moderator
  Admin
}

model Message {
  id String @id @default(uuid())
  
  conversationId String
  userId String // sender
  
  content String @db.Text
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt // if updatedAt > createdAt, isEdited = true
  
  // relations
  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([conversationId])
  @@index([userId])
  @@index([createdAt])
}

// note: if we do need per-message read receipts for DMs later, we can j add a new MessageRead model.
// for now, using lastReadAt on ConversationParticipant/ChannelMember for unread counts