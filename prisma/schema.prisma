// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// todo: h-index, students under professors, and projects
model User {
  id String @id

  firstName String?
  lastName String?
  designation String?
  institution String?
  title String?
  location String?
  website String?
  bio String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  following Connection[] @relation("Following")
  followers Connection[] @relation("Followers")

  // Research relationships
  researchInterests ResearchInterest[]
  publications Publication[]
  
  // Event relationships
  eventRegistrations EventRegistration[]
  eventReviews EventReview[]
  bookmarkedEvents Event[] @relation("EventBookmarks")
  organizedEvents Event[] @relation("EventOrganizer")
  eventSpeakers EventSpeaker[] @relation("EventSpeakers")
  sessionSpeakers SessionSpeaker[]
  posterAuthors PosterAuthor[]
  
  // Group relationships
  ledGroups Group[] @relation("GroupLeader")
  groupMemberships GroupMember[]
  groupAnnouncements GroupAnnouncement[]
  groupProjectMembers GroupProjectMember[]
}

model Connection {
  id String @id @default(uuid())

  followerId String
  followingId String
  status ConnectionStatus @default(Pending)

  createdAt DateTime @default(now())

  follower User @relation("Following", fields: [followerId], references: [id], onDelete: Cascade) // should we have onDelete: Cascade here?
  following User @relation("Followers", fields: [followingId], references: [id], onDelete: Cascade)
}

enum ConnectionStatus {
  Pending
  Accepted
  Rejected
}

// ============================================
// Publication Models
// ============================================
model Publication {
  id String @id @default(uuid())

  title String
  abstract String? @db.Text
  publicationDate DateTime?
  journal String?
  doi String? @unique // digital object identifier should be unique

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  authors User[] // should we store the order of authors? if yes, we need to create a new join table 

  citations_made Publication[] @relation("Citations")
  citations_received Publication[] @relation("Citations")
}

model ResearchInterest {
  id String @id @default(uuid())

  interest String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  users User[]
}

// ============================================
// Event Models
// ============================================

model Event {
  id String @id @default(uuid())
  
  title String
  subtitle String?
  description String? @db.Text
  fullDescription String? @db.Text
  
  type EventType
  format EventFormat
  
  startDate DateTime
  endDate DateTime
  timezone String?
  
  price String? // can be free, $50, etc.
  currency String? // can be USD, EUR, etc.
  
  organizerId String?
  organizerName String?
  organizerLogo String?
  
  image String?
  website String?
  twitterHandle String?
  linkedinHandle String?
  isLive Boolean @default(false)
  isFeatured Boolean @default(false)
  
  maxAttendees Int?
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // relations
  organizer User? @relation("EventOrganizer", fields: [organizerId], references: [id])
  tags EventTag[]
  sessions Session[]
  speakers EventSpeaker[]
  posters Poster[]
  registrations EventRegistration[]
  reviews EventReview[]
  bookmarks User[] @relation("EventBookmarks")
  
  @@index([type])
  @@index([format])
  @@index([startDate])
  @@index([endDate])
  @@index([isLive])
  @@index([isFeatured])
  @@index([organizerId])
}

enum EventType {
  Conference
  Workshop
  Symposium
  Seminar
  Webinar
  Other
}

enum EventFormat {
  Virtual
  InPerson
  Hybrid
}

model EventTag {
  id String @id @default(uuid())
  
  name String
  slug String? @unique
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  events Event[]
}

model Session {
  id String @id @default(uuid())
  
  eventId String
  title String
  description String? @db.Text
  
  startTime DateTime
  endTime DateTime
  timezone String?
  
  type SessionType
  
  room String?
  location String? // can be virtual gallery, track A, etc.
  
  videoUrl String?
  recordingUrl String?
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // relations
  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
  speakers SessionSpeaker[]
  
  @@index([eventId])
  @@index([startTime])
  @@index([type])
}

enum SessionType {
  Keynote
  Session
  Poster
  Workshop
  Tutorial
}
model SessionSpeaker {
  id String @id @default(uuid())
  
  sessionId String
  userId String
  
  role SessionSpeakerRole? 
  order Int? // for ordering multiple speakers - maybe not needed?
  
  createdAt DateTime @default(now())
  
  // relations
  session Session @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([sessionId, userId])
  @@index([sessionId])
  @@index([userId])
}

enum SessionSpeakerRole {
  KeynoteSpeaker
  Presenter
  Moderator
}
model EventSpeaker {
  id String @id @default(uuid())
  
  eventId String
  userId String? // optional since speaker might not be a user
  
  name String? // if speaker is not a user
  title String? // professor, university of X
  bio String? @db.Text
  image String?
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // relations
  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user User? @relation("EventSpeakers", fields: [userId], references: [id], onDelete: SetNull)
  
  // note - no unique constraint on [eventId, userId] because userId is nullable
  // multiple external speakers (no userId) can exist for same event
  @@index([eventId])
  @@index([userId])
}

model Poster {
  id String @id @default(uuid())
  
  eventId String
  title String
  abstract String? @db.Text
  
  imageUrl String?
  pdfUrl String?
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // relations
  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
  authors PosterAuthor[]
  
  @@index([eventId])
}

model PosterAuthor {
  id String @id @default(uuid())
  
  posterId String
  userId String
  
  order Int? // author order - maybe not needed?
  
  createdAt DateTime @default(now())
  
  // relations
  poster Poster @relation(fields: [posterId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([posterId, userId])
  @@index([posterId])
  @@index([userId])
}

model EventRegistration {
  id String @id @default(uuid())
  
  eventId String
  userId String
  
  status EventRegistrationStatus @default(Registered)
  
  registeredAt DateTime @default(now())
  cancelledAt DateTime?
  
  // relations
  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([eventId, userId])
  @@index([eventId])
  @@index([userId])
  @@index([status])
}

enum EventRegistrationStatus {
  Registered
  Cancelled
  Waitlisted
}

model EventReview {
  id String @id @default(uuid())
  
  eventId String
  userId String
  
  rating Int // 1-5
  comment String? @db.Text
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // relations
  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([eventId, userId])
  @@index([eventId])
  @@index([userId])
  @@index([rating])
}

// ============================================
// Research Group Models
// ============================================

model Group {
  id String @id @default(uuid())
  
  name String
  description String? @db.Text
  fullDescription String? @db.Text
  
  field String? // research field
  institution String?
  
  leaderId String
  founded DateTime? // when the group was founded
  
  maxMembers Int?
  
  // Privacy & Access Settings
  visibility GroupVisibility @default(Public)
  joinRequiresApproval Boolean @default(false)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // relations
  leader User @relation("GroupLeader", fields: [leaderId], references: [id], onDelete: Cascade)
  members GroupMember[]
  topics GroupTopic[]
  projects GroupProject[]
  announcements GroupAnnouncement[]
  
  @@index([leaderId])
  @@index([field])
  @@index([institution])
  @@index([createdAt])
  @@index([visibility])
}

enum GroupVisibility {
  Public
  Private
  Unlisted
}

model GroupMember {
  id String @id @default(uuid())
  
  groupId String
  userId String
  
  role GroupMemberRole?
  status GroupMemberStatus @default(Active)
  
  // Admin permissions
  isAdmin Boolean @default(false) // allows managing group settings and members
  
  joinedAt DateTime @default(now())
  leftAt DateTime?
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // relations
  group Group @relation(fields: [groupId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([groupId, userId])
  @@index([groupId])
  @@index([userId])
  @@index([status])
  @@index([role])
  @@index([isAdmin])
}

enum GroupMemberRole {
  Founder
  Lead
  SeniorResearcher
  Researcher
  Postdoc
  PhDStudent
  MastersStudent
  ResearchAssistant
  Other
}

enum GroupMemberStatus {
  Active
  Pending
  Left
}

model GroupTopic {
  id String @id @default(uuid())
  
  name String
  slug String? @unique
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  groups Group[]
}

model GroupProject {
  id String @id @default(uuid())
  
  groupId String
  name String
  description String? @db.Text
  
  status GroupProjectStatus @default(Planning)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // relations
  group Group @relation(fields: [groupId], references: [id], onDelete: Cascade)
  members GroupProjectMember[]
  
  @@index([groupId])
  @@index([status])
}

enum GroupProjectStatus {
  Planning
  Active
  OnHold
  Completed
  Cancelled
}

model GroupProjectMember {
  id String @id @default(uuid())
  
  projectId String
  userId String
  
  role String? // project-specific role
  
  joinedAt DateTime @default(now())
  
  createdAt DateTime @default(now())
  
  // relations
  project GroupProject @relation(fields: [projectId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([projectId, userId])
  @@index([projectId])
  @@index([userId])
}

model GroupAnnouncement {
  id String @id @default(uuid())
  
  groupId String
  userId String
  
  title String
  content String? @db.Text
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // relations
  group Group @relation(fields: [groupId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([groupId])
  @@index([userId])
  @@index([createdAt])
}